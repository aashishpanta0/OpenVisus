import sysfrom skimage import ioimport numpy as npfrom OpenVisus import *def ASSERT(cond):    if not cond: raise Exception("Assert failed")   if __name__ == '__main__':		"""	Example of data conversion		Input is composed of 3 images, one for each channel (RGB)		Ouput is an IDX		For each source slice the original data is shifted by 5 pixels:		first  slice is shifted by ( 0,0)		second slice is shifted by ( 5,0)		third  slice is shifted by (10,0)			"""	SetCommandLine("__main__")	IdxModule.attach()	# trick to speed up the conversion	os.environ["VISUS_DISABLE_WRITE_LOCK"]="1"	# each file is a channel	filenames = [	    'channel_red.png',	    'channel_green.png',	    'channel_blue.png',	]	              	idx_filename='visus.idx'	# for each slize along Z axis I shift the original data of offset[0],offset[1],offset[2] (like a shear)	offset = (5,0,0)	dataset,access,fields=None,None,None	for ChannelId,filename in enumerate(filenames):	    channel = io.imread(filename)	    	    # scrgiorgio: just for testing, if I get a 2d image instead of a 3d image stack I simulate a stack	    if len(channel.shape)==2: 	        channel=np.stack([channel]*7)	    	    dims=list(reversed(channel.shape))	    	    # numpy dtype -> OpenVisus dtype	    typestr=channel.__array_interface__["typestr"]	    dtype=DType(typestr[1]=="u", typestr[1]=="f", int(typestr[2])*8)        	    	    idx_box=NdBox(NdPoint(0,0,0),NdPoint.one(	            dims[0]+ offset[0]*dims[2],	            dims[1]+ offset[1]*dims[2],	            dims[2]+ offset[2]*dims[2]))	            	    # create the idx 	    if ChannelId==0:	        print("Creating idx file")	        idx_file = IdxFile()	        idx_file.box=idx_box	        print("\tbox",idx_box.toString())	        	        # assuming all the files are the same type	        for I in range(len(filenames)): 	            field=Field('channel_%d' % (I,),dtype)	            print("\tfield",field.name,field.dtype.toString())	            idx_file.fields.push_back(field)	        	        ASSERT(idx_file.save(idx_filename)) 	        dataset = LoadDataset(idx_filename);ASSERT(dataset)	        access = dataset.createAccess();ASSERT(access)	        fields=idx_file.fields	        	    else:	        # check dimensions and dtype are compatible	        ASSERT(dataset.getBox()==idx_box)	        ASSERT(dtype==fields[ChannelId].dtype)	        	    print("Adding",filename,"dims",dims,"dtype",dtype.toString())  	        	    # Now we go through each slice and add them one by one since we have to take care of the offset	    for Z in range(0,dims[2]):	    	        # target area in idx (i.e. apply a shear)	        x1,x2 = 0+offset[0]*Z , dims[0]+offset[0]*Z	        y1,y2 = 0+offset[1]*Z , dims[1]+offset[1]*Z	        z1,z2 = Z+offset[2]*Z , Z+1    +offset[2]*Z	      	        print("\tProcessing Z",Z,"target_p1",(x1, y1, z1),"target_p2",(x2, y2, z2))	               	        query = Query(dataset,ord('w')) 	        query.position = Position(NdBox(NdPoint.one(x1,y1,z1),NdPoint.one(x2,y2,z2)))	        query.field = fields[ChannelId] 	        ASSERT(dataset.beginQuery(query))	        query.buffer=Array.fromNumPy(channel[Z,:,:],bShareMem=True)	        ASSERT(dataset.executeQuery(access,query))  	IdxModule.detach()	print("Done with conversion")